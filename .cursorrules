# XSLT to PDFMake Converter - Cursor Rules

## ⚠️ Quick Checklist for New Tag Converters

When implementing ANY new XSL-FO element converter:

| Step | Action | Required |
|------|--------|----------|
| 1 | Create separate module file (e.g., `src/table-converter.js`) | ✅ YES |
| 2 | **Call `trimEdgeSpaces(children)` at start of converter** | ✅ YES |
| 3 | Import `trimEdgeSpaces` from `block-converter.js` if in new module | ✅ YES |
| 4 | Export for both browser and Node.js | ✅ YES |
| 5 | Add JSDoc documentation | ✅ YES |
| 6 | Create test suite with whitespace tests | ✅ YES |
| 7 | Register tests in test-cli.js and test.html | ✅ YES |

**Critical:** Never forget step 2! All converters must normalize whitespace.

---

## Project Structure

- **Main converter**: `src/xslt-to-pdfmake.js` (browser + Node.js compatible)
- **Feature modules**: `src/*.js` (separate files for each feature/functionality)
- **Utilities**: `src/doc-definition-formatter.js` (shared utilities)
- **CLI test runner**: `test/test-cli.js`
- **Browser test runner**: `test/test.html`
- **Test files**: `test/tests/*.test.js`
- **Sample data**: `test/data/*.xslt`

---

## Code Organization Rules ⚠️ CRITICAL

### **DO NOT add new feature functions directly to `src/xslt-to-pdfmake.js`**

To keep the codebase maintainable and prevent file bloat, **ALL new feature implementations MUST be created in separate module files**.

**Important**: You CAN add methods to the main converter class if they're core infrastructure (like existing `convertToPoints`, `parseMargins`, etc.), but NEW FEATURE LOGIC (like block conversion, table parsing, image handling) should be in separate modules.

**Examples:**
- ✅ **CAN add to xslt-to-pdfmake.js**: Core utility methods, infrastructure, coordination logic
- ❌ **MUST extract to separate module**: Block converter logic, table parser, font handler, image processor

### **⚠️ CRITICAL: Whitespace Normalization for All Tag Converters**

When implementing converters for ANY XSL-FO element (blocks, inlines, tables, lists, etc.), you MUST apply HTML-like whitespace normalization using the `trimEdgeSpaces()` helper function.

**Why This Matters:**
- XSL-FO XML often contains formatting whitespace (newlines, indentation) that should be removed
- Meaningful spaces between content (e.g., between words, between inline elements) MUST be preserved
- Edge spaces touching the parent element's tags should be trimmed

**The Rule:**
```javascript
// At the start of ANY converter function (block, table, list, etc.)
function convertYourElement(node, children, traverse) {
    // Apply HTML-like edge whitespace trimming
    children = trimEdgeSpaces(children);
    
    // ... rest of your conversion logic
}
```

**What `trimEdgeSpaces()` Does:**
1. **Trims leading spaces** from the first text child (touching parent's opening tag)
2. **Trims trailing spaces** from the last text child (touching parent's closing tag)  
3. **Preserves ALL internal spaces** between siblings (meaningful separation)
4. **Filters whitespace-only nodes** (already handled by recursive-traversal.js)

**Examples:**

✅ **Edge Trimming:**
```xml
<fo:block> Hello world </fo:block>
```
→ `"Hello world"` (edges trimmed)

✅ **Sibling Space Preservation:**
```xml
<fo:block>Text <fo:inline color="red">red</fo:inline> more</fo:block>
```
→ `["Text ", {red inline}, " more"]` (spaces between siblings preserved)

✅ **Applies to ALL elements:**
```xml
<fo:table-cell> Content </fo:table-cell>
```
→ `"Content"` (edges trimmed)

**Location:** The `trimEdgeSpaces()` function is in `src/block-converter.js` and is exported for use in other converters.

**Remember:** If you're implementing a new tag converter (table, list, image, etc.) and it processes children, ALWAYS call `trimEdgeSpaces(children)` first!

---

### When Adding New Functionality

**1. Create a New Module File:**
```javascript
// src/{feature-name}.js

/**
 * {Feature Name} Module
 * {Description of what this module does}
 */

/**
 * {Function description}
 * @param {Type} paramName - Description
 * @returns {Type} Description
 */
function featureFunctionName(param) {
    // Implementation
    return result;
}

// Export for both browser and Node.js
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { featureFunctionName };
}
if (typeof window !== 'undefined') {
    window.featureFunctionName = featureFunctionName;
}
```

**2. Import in `src/xslt-to-pdfmake.js`:**
```html
<!-- In HTML files that use the converter: -->
<script src="src/{feature-name}.js"></script>
<script src="src/xslt-to-pdfmake.js"></script>
```

```javascript
// In Node.js/CLI (test-cli.js):
const { featureFunctionName } = require('../src/{feature-name}.js');
```

**3. Use in Converter Class:**
```javascript
class XSLToPDFMakeConverter {
    someMethod() {
        // Use the imported function
        const result = featureFunctionName(data);
        return result;
    }
}
```

### File Size Guidelines & When to Extract

- **`src/xslt-to-pdfmake.js`**: Core converter class with infrastructure methods (ideally < 500 lines)
  - Can contain: coordination, simple utilities, core converter methods
  - Should NOT contain: new feature implementations, complex parsing logic
  
- **Feature modules**: Keep focused on single responsibility (< 200 lines each)
  - One module per XSL-FO element type (block, table, list, etc.)
  - One module per distinct feature (fonts, images, layouts, etc.)

- **When to extract to separate module:**
  - Adding a new XSL-FO element converter (e.g., `<fo:block>`, `<fo:table>`)
  - Adding complex feature logic (> 50 lines for one feature)
  - Adding functionality that will grow/evolve independently
  - Adding anything that's not core infrastructure

### Examples of What Should Be Separate Modules

✅ **Create separate files for NEW FEATURES:**
- Block conversion logic (e.g., `src/block-converter.js`) ← **NEW feature implementation**
- Table processing (e.g., `src/table-converter.js`) ← **NEW feature implementation**
- List handling (e.g., `src/list-converter.js`) ← **NEW feature implementation**
- Image processing (e.g., `src/image-handler.js`) ← **NEW feature implementation**
- Font parsing (e.g., `src/font-parser.js`) ← **Complex feature logic**
- Complex formatting utilities (e.g., `src/doc-definition-formatter.js`)

✅ **CAN remain in or be added to `xslt-to-pdfmake.js`:**
- Core converter class methods (orchestration)
- Simple utility methods like `convertToPoints()`, `parseMargins()`
- Infrastructure methods that coordinate between modules
- Small helper functions used across the main converter

❌ **NEVER add NEW FEATURE IMPLEMENTATIONS directly to `xslt-to-pdfmake.js`:**
- Large parsing functions for specific elements (blocks, tables, etc.)
- Complex transformation logic for features
- Element-specific conversion logic
- Feature modules that will grow over time

### Module Template

```javascript
/**
 * {Module Name}
 * {Purpose and description}
 */

// Private helper functions (not exported)
function privateHelper(data) {
    return processed;
}

// Public API functions (exported)
function publicFunction(input) {
    const result = privateHelper(input);
    return result;
}

// Export for both environments
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { 
        publicFunction
        // Add other exports as needed
    };
}
if (typeof window !== 'undefined') {
    window.ModuleName = { publicFunction };
    // Or individual exports:
    // window.publicFunction = publicFunction;
}
```

---

## How to Add a New Test

### 1. Create Test File: `test/tests/{feature-name}.test.js`

```javascript
function register{FeatureName}Tests(testRunner, converter, emptyPageXML, assert) {
    testRunner.addTest('Should {describe expected behavior}', () => {
        const testData = '...';
        const result = converter.someMethod(testData);
        assert.ok(result, 'Should return a result');
        assert.equal(result.property, expectedValue, 'Property should match expected value');
    });
}

// Export for both browser and Node.js
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { register{FeatureName}Tests };
}
if (typeof window !== 'undefined') {
    window.register{FeatureName}Tests = register{FeatureName}Tests;
}
```

### 2. Update `test/test-definitions.js`

```javascript
if (typeof register{FeatureName}Tests === 'function') {
    register{FeatureName}Tests(testRunner, converter, emptyPageXML, assert);
}
```

### 3. Update `test/test-cli.js` (around line 290)

```javascript
const { register{FeatureName}Tests } = require('./tests/{feature-name}.test.js');
register{FeatureName}Tests(testRunner, converter, emptyPageXML, assert);
```

### 4. Update `test/test.html`

```html
<script src="tests/{feature-name}.test.js"></script>
```

### 5. Map Test Data in `test/test.html` (if using different sample data)

If your test uses a different XSL-FO sample file (not `empty_page.xslt`), add it to the `testSuites` array in `registerTestsWrapper()`:

```javascript
// Load the data file first (in loadTestData function)
{featureName}XML = await loadTestFile('data/{feature-name}.xslt');

// Then add to testSuites array
const testSuites = [
    { registerFn: registerPageStructureTests, xml: emptyPageXML, name: 'empty_page.xslt' },
    // ... other tests ...
    { registerFn: register{FeatureName}Tests, xml: {featureName}XML, name: '{feature-name}.xslt' }
];
```

---

## How to Add Sample Test Data

### 1. Create XSL-FO file: `test/data/{description}.xslt`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<fo:root xmlns:fo="http://www.w3.org/1999/XSL/Format">
  <fo:layout-master-set>
    <fo:simple-page-master master-name="MyTest" page-width="8.5in" page-height="11in" margin="1in">
      <fo:region-body margin="0.5in"/>
    </fo:simple-page-master>
  </fo:layout-master-set>
  <fo:page-sequence master-reference="MyTest">
    <fo:flow flow-name="xsl-region-body">
      <fo:block>Your test content here</fo:block>
    </fo:flow>
  </fo:page-sequence>
</fo:root>
```

### 2. Load in CLI Runner

```javascript
const myFeatureXML = fs.readFileSync(path.join(__dirname, 'data', 'my_feature.xslt'), 'utf-8');
register{FeatureName}Tests(testRunner, converter, myFeatureXML, assert);
```

---

## How to Add a New Feature to Converter

### 1. Add Method to `src/xslt-to-pdfmake.js`

```javascript
/**
 * Your new method
 * @param {string} input - Description
 * @returns {any} Description
 */
yourNewMethod(input) {
    // Implementation
    return result;
}
```

### 2. Update CLI Version (if needed)

If using browser-specific APIs (like DOMParser), add Node.js version in `test/test-cli.js` (lines 54-183).

### 3. Add Tests

Create test file following "How to Add a New Test" steps above.

---

## Assertion Methods

```javascript
assert.ok(value, message)                              // Truthy check
assert.equal(actual, expected, message)                 // Strict equality (===)
assert.deepEqual(actual, expected, message)             // JSON comparison
assert.approximately(actual, expected, tolerance, msg)  // Numeric tolerance
```

---

## Key Converter Methods

```javascript
converter.convertToPoints(value)                      // "8.5in" → 612
converter.parseMargins(marginStr)                     // "1in 2in" → [144, 72, 144, 72]
converter.determinePageSize(width, height)            // 612, 792 → "LETTER"
converter.parsePageMasters(xslfoXml)                  // Returns array of page master objects
converter.convertToPDFMake(xslfoXml)                  // Returns PDFMake document definition
```

---

## Naming Conventions

- Test files: `{feature-name}.test.js` (kebab-case)
- Test functions: `register{FeatureName}Tests` (PascalCase)
- Test descriptions: Start with "Should {describe behavior}"
- Sample data: `{description}.xslt` (lowercase with underscores)

---

## Running Tests

```bash
node test/test-cli.js
```

Or open `test/test.html` in browser.

---

## Quick Reference Checklist

### Adding a New Test Suite
- [ ] Create `test/tests/{feature-name}.test.js`
- [ ] Implement `register{FeatureName}Tests` function
- [ ] Export for browser and Node.js
- [ ] Add to `test/test-definitions.js` registerTests function
- [ ] Add require/import in `test/test-cli.js` (around line 290)
- [ ] Add script tag in `test/test.html`
- [ ] **If using custom sample data:** Add to `testSuites` array in `test/test.html` `registerTestsWrapper()`
- [ ] Run tests: `node test/test-cli.js`

### Adding Sample Data
- [ ] Create `test/data/{description}.xslt`
- [ ] Ensure valid XSL-FO XML format
- [ ] Load in browser test runner (`test/test.html` `loadTestData()` function)
- [ ] Load in CLI test runner (`test/test-cli.js` main function)
- [ ] Map to test suite in `test/test.html` `testSuites` array
- [ ] Reference in tests

### Adding a Converter Feature
- [ ] **Create new module file** `src/{feature-name}.js` (DO NOT add to xslt-to-pdfmake.js)
- [ ] **⚠️ Apply `trimEdgeSpaces(children)` at start of converter** (for HTML-like whitespace normalization)
- [ ] Implement feature with proper exports for browser 
- [ ] Add JSDoc documentation
- [ ] Import module in `src/xslt-to-pdfmake.js` (or use directly)
- [ ] Update HTML files to load the new module script
- [ ] Update CLI version (test-cli.js) to require the module if needed
- [ ] Create test suite for new feature
- [ ] Add whitespace normalization tests (edge trimming, sibling preservation)
- [ ] Verify browser and CLI tests pass

---

## Example: Adding a New Feature Module

Let's say you want to add "table parsing" functionality:

**1. Create module** (`src/table-parser.js`):
```javascript
/**
 * Table Parser Module
 * Parses XSL-FO table elements to PDFMake table definitions
 */

// Import trimEdgeSpaces from block-converter
const { trimEdgeSpaces } = require('./block-converter.js');

function parseTable(node, children, traverse) {
    // ⚠️ CRITICAL: Apply HTML-like whitespace normalization
    children = trimEdgeSpaces(children);
    
    // Implementation
    return {
        table: {
            body: [/* rows */]
        }
    };
}

function parseTableRow(node, children, traverse) {
    // ⚠️ CRITICAL: Apply whitespace normalization for row children too
    children = trimEdgeSpaces(children);
    
    // Implementation
    return [/* cells */];
}

// Export
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { parseTable, parseTableRow };
}
if (typeof window !== 'undefined') {
    window.TableParser = { parseTable, parseTableRow };
}
```

**2. Use in converter** (`src/xslt-to-pdfmake.js`):
```javascript
class XSLToPDFMakeConverter {
    convertContent(xslfoXml) {
        // Use the table parser
        const tables = TableParser.parseTable(tableElement);
        return tables;
    }
}
```

**3. Update HTML files**:
```html
<script src="src/table-parser.js"></script>
<script src="src/xslt-to-pdfmake.js"></script>
```

**4. Update CLI if needed** (`test/test-cli.js`):
```javascript
const { parseTable } = require('../src/table-parser.js');
```

**5. Create tests** (`test/tests/table-parsing.test.js`)

Done! ✅ The main converter file stays clean and focused.

---

## Example: Complete Test Addition

Let's say you want to test a new "font parsing" feature:

**1. Create test file** (`test/tests/font-parsing.test.js`):
```javascript
function registerFontParsingTests(testRunner, converter, emptyPageXML, assert) {
    testRunner.addTest('Should parse font-family attribute', () => {
        const fontFamily = converter.parseFontFamily('Arial, sans-serif');
        assert.equal(fontFamily, 'Arial');
    });
}

if (typeof module !== 'undefined' && module.exports) {
    module.exports = { registerFontParsingTests };
}
if (typeof window !== 'undefined') {
    window.registerFontParsingTests = registerFontParsingTests;
}
```

**2. Update test-definitions.js**:
```javascript
if (typeof registerFontParsingTests === 'function') {
    registerFontParsingTests(testRunner, converter, emptyPageXML, assert);
}
```

**3. Update test-cli.js**:
```javascript
const { registerFontParsingTests } = require('./tests/font-parsing.test.js');
// ...
registerFontParsingTests(testRunner, converter, emptyPageXML, assert);
```

**4. Update test.html**:
```html
<script src="tests/font-parsing.test.js"></script>
```

**5. Implement feature logic** (in separate module if it's a new feature):

For a **simple utility method** (can go in main converter):
```javascript
// In src/xslt-to-pdfmake.js
parseFontFamily(fontFamily) {
    if (!fontFamily) return 'Helvetica';
    return fontFamily.split(',')[0].trim();
}
```

For a **new feature** (must be in separate module):
```javascript
// In src/font-parser.js
function parseFontFamily(fontFamily) {
    if (!fontFamily) return 'Helvetica';
    return fontFamily.split(',')[0].trim();
}

function parseFontWeight(weight) { /* ... */ }
function parseFontStyle(style) { /* ... */ }

// Export
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { parseFontFamily, parseFontWeight, parseFontStyle };
}
```

Done! Run `node test/test-cli.js` to verify.

---

## Summary

This document provides everything needed to add tests, samples, and features without searching through multiple files. Follow the patterns established in existing test files for consistency.

For questions or issues, refer to existing test files as working examples:
- `test/tests/page-structure.test.js` - Document structure tests
- `test/tests/unit-conversion.test.js` - Utility function tests  
- `test/tests/margin-parsing.test.js` - Parsing logic tests
